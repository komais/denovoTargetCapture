#Cheryl Hojnowski HW5

#1a Yes this should result in an infinite loop -- no condition created that could end up being not true.
#1b I thought this should result in an infinite loop as well (same reasoning as for 1a), but when I try it in R it
  #just does nothing -- why?
#1c while(1), while (2) and while(100) result in an infinite loop, but while (0) results in nothing happening -- 
  #but I don't understand why. 
#1d This should result in an infinite loop because x is always equal to 5.
#1e Should not result in an infinite loop. 
#1f Should not result in an infinite loop


#Random number generator digression
system.time(rnorm(1000000))
system.time(sum(1:10000))

#a
x<-rnorm(1000, mean=5, sd=2);
x;
hist(x);

#b
x<-rnorm(100, mean=0, sd=10);
hist(x);

#c
x<-rnorm(100, mean=0, sd=2);
hist(x);

#d
x<-rnorm(100, mean=0, sd=10);
length(which(x>2));

x<-rnorm(100, mean=0, sd=2);
which(x>2);
length(which(x>2));

for(i in 1:5){
  print(runif(5));
}

for(i in 1:5){
  set.seed(1);
  print(runif(5));
}

#2a
system.time(rnorm(10000000, mean=0, sd=1));
#0.92 elapsed
#2b
system.time(rpois(10000000, lambda=2));
#0.46 elapsed
#2c
system.time(runif(10000000, min=0, max=1.5));
#0.34 elapsed
#2d
system.time(rgeom(10000000, 0.5))
#1.19 elapsed
#2e
system.time(rbinom(1, size=10000000, prob=0.5));
#0.03 elapsed

#It is fastest to simulate from the binomial distribution
#It is slowest to simulate from the geometric distribution

#3
set.seed(1);
x<-numeric(7);
for(i in 1:7){
  x[i]<-system.time(rnorm(5000000, mean=10^(i-1)));
  cat('time to run is ', x, '\n');
}

x;

#OR:
set.seed(1);

for(i in 1:7){
  x<-system.time(rnorm(5000000, mean=10^(i-1)));
  cat('time to run is ', x, '\n');
}

#QUESTION: What are the three numbers generated by the system.time function (user, system and elapsed)? 
  #Which ones do I need to care about? And why does printing to the console generate something like, 
  #"time to run is 0.49 0 0.48 NA NA"? If I create a vector of system time results, which of the 3 numbers
  #(user, system or elapsed) are being copied into my vector and does this matter?

#4 The 0's and 1's are failures and successes, respectively.
rbinom(5, size=1, prob=0.5);
rbinom(10, size=1, prob=0.5);
rbinom(20, size=1, prob =0.5);
rbinom(5, size=1, prob=0.8);
rbinom(10, size=1, prob=0.8);
system.time(rbinom(20, size=1, prob=0.8));

#5a
#WHILE the population size is less than the maximum population size
  #add progeny to the population using a geometric distribution with p = 0.3333 (rate of 2 progeny/individual);
  #make the current population size equal to the total number (sum) of progeny;
  #record the current population size at each generation in a population size vector;
  #record the length of each population size vector (this is equal to the total number of generations to 
    #reach/exceed the max size) in another number of generations vector ;
  #repeat 1000 times;
  #plot a histogram of the number of generations vector.

#5b

ngens<-numeric(1000); #holds the number of generations for each simulation
reps<-1000; #number of simulations
set.seed(1); #note if you set.seed inside your for loop, then you will always get the exact same population vector
  #for all 1000 simulations

for(i in 1:reps){
  
  maxpopsize<-10000;
  curr_pop_size<-20;
  popvector<-curr_pop_size; #initialize the population vector
  
  while(curr_pop_size < maxpopsize){
    curr_pop_size<-sum(rgeom(curr_pop_size, 0.3333));
    popvector<-c(popvector, curr_pop_size);
    ngens[i]<-length(popvector);
  }
}
popvector;
ngens;

#5c
hist(ngens);

#5d

ngens<-numeric(1000); #holds the number of generations for each simulation
reps<-1000; #number of simulations
set.seed(1); #note if you set.seed inside your for loop, then you will always get the exact same population vector
  #for all 1000 simulations

for(i in 1:reps){
  
  maxpopsize<-10000;
  curr_pop_size<-20;
  popvector<-curr_pop_size; #initialize the population vector
  
  while(curr_pop_size < maxpopsize){
    curr_pop_size<-sum(rgeom(curr_pop_size, 0.25));
    popvector<-c(popvector, curr_pop_size);
    ngens[i]<-length(popvector);
  }
}
popvector;
ngens;
hist(ngens);

ngens<-numeric(1000); #holds the number of generations for each simulation
reps<-1000; #number of simulations
set.seed(1); #note if you set.seed inside your for loop, then you will always get the exact same population vector
  #for all 1000 simulations

for(i in 1:reps){
  
  maxpopsize<-10000;
  curr_pop_size<-20;
  popvector<-curr_pop_size; #initialize the population vector
  
  while(curr_pop_size < maxpopsize){
    curr_pop_size<-sum(rgeom(curr_pop_size, 0.2));
    popvector<-c(popvector, curr_pop_size);
    ngens[i]<-length(popvector);
  }
}
popvector;
ngens;
hist(ngens);

#5e

#I copied the following text into a separate file called "popsimulation.R" and enter into R: source("popsimulation.R")
#see popsimulation.R file . Then I did:

source("popsimulation.R");

#QUESTION: Were we supposed to do this as I did it or using nested for loops and if statements?

ngens2<-numeric(1000); #holds the number of generations for each simulation
reps<-1000; #number of simulations
set.seed(1); #note if you set.seed inside your for loop, then you will always get the exact same population vector
  #for all 1000 simulations

for(i in 1:reps){
  
  maxpopsize<-10000;
  curr_pop_size<-20;
  popvector<-curr_pop_size; #initialize the population vector
  
  while(curr_pop_size < maxpopsize){
    curr_pop_size<-sum(rgeom(curr_pop_size, 0.3333));
    popvector<-c(popvector, curr_pop_size);
    ngens2[i]<-length(popvector);
  }
}

cat('For progeny =2, mean number of gens = ', mean(ngens2), '\n');

ngens3<-numeric(1000); #holds the number of generations for each simulation
reps<-1000; #number of simulations
set.seed(1); #note if you set.seed inside your for loop, then you will always get the exact same population vector
  #for all 1000 simulations

for(i in 1:reps){
  
  maxpopsize<-10000;
  curr_pop_size<-20;
  popvector<-curr_pop_size; #initialize the population vector
  
  while(curr_pop_size < maxpopsize){
    curr_pop_size<-sum(rgeom(curr_pop_size, 0.25));
    popvector<-c(popvector, curr_pop_size);
    ngens3[i]<-length(popvector);
  }
}

cat('For progeny =3, mean number of gens = ', mean(ngens3), '\n');

ngens4<-numeric(1000); #holds the number of generations for each simulation
reps<-1000; #number of simulations
set.seed(1); #note if you set.seed inside your for loop, then you will always get the exact same population vector
  #for all 1000 simulations

for(i in 1:reps){
  
  maxpopsize<-10000;
  curr_pop_size<-20;
  popvector<-curr_pop_size; #initialize the population vector
  
  while(curr_pop_size < maxpopsize){
    curr_pop_size<-sum(rgeom(curr_pop_size, 0.2));
    popvector<-c(popvector, curr_pop_size);
    ngens4[i]<-length(popvector);
  }
}

cat('For progeny =4, mean number of gens = ', mean(ngens4), '\n');


par(mfrow = c(3, 1));

hist(ngens2, xlim=c(5,15), ylim=c(0,1000));
hist(ngens3, xlim=c(5,15), ylim=c(0,1000));
hist(ngens4, xlim=c(5,15), ylim=c(0,1000));

#QUESTION: Why doesn't it work to set the plot window separately using the following:
  #plot.window(xlim=c(5,15), ylim=c(0,1000)); 
  #? I tried putting this plot.window line in before, in the middle of, and after lines 246-250, but it never worked.

#6a

x<-rgeom(1000, 0.25);
x;

y<-numeric(1000);
reps<-1000;

for(i in 1:reps){
  y[i]<-sum(rgeom(10, 0.25))
}

y;

z<-numeric(1000);
reps<-1000;

for(i in 1:reps){
  z[i]<-sum(rgeom(1000, 0.25))
}

z;

par(mfrow=c(3,1));
hist(x);
hist(y);
hist(z);

#Histogram gets more normally distributed (bell-shaped) as increase number of simulations and sums. 
  #Thus hist(z) is more bell-shaped than y is more bell-shaped than x. Same logic applies for 6b.

#6b

x<-runif(1000, min = -1, max=5);
x;

y<-numeric(1000);
reps<-1000;

for(i in 1:reps){
  y[i]<-sum(runif(10, min = -1, max = 5));
}

y;

z<-numeric(1000);
reps<-1000;

for(i in 1:reps){
  z[i]<-sum(runif(1000, min = -1, max=5));
}

z;

par(mfrow=c(3,1));
hist(x);
hist(y);
hist(z);

#7a This is a sequence of 1000 coin-tossing experiments (each experiment has one trial), where the probability of heads 
  #on each trial is p =0.7. The output will be a vector of 1000 random numbers, where each random number is the number of heads that 
  #occurred in the one coin flip. (Therefore the 1000 random numbers can only be of the value 0 or 1)
#7b This is one coin-tossing experiment with 14 trials; the probability of heads on each trial is 0.5. The ourput will
  #be one random number that is equal to the number of heads that occurred in the 14 coin flips (trials). The largest
  #number that could be returned is 14 (heads on all trials), and the smallest is 0 (no heads on any trials).
#7c This is the sum of the number of heads obtained in 1000 coin-tossing experiments with one trial each, where the probability of heads on 
  #each trial is 0.5 . The largest value you could obtain would be 1000, if all trials in all experiments result in heads. 
#7d
rbinom(1, size=1000, prob=0.5);

#8a
#One experiment is 200 coin flips. In total I will do a lot of experiments, say at least 1000. For each experiment, I want
  #to tabulate the total number of heads.

#8b
#Create a vector to store the outcomes of each simulation (i.e., the vector is a vector of 5000 numbers, each 
  #representing the total number of heads out of 200 trials). 
#Determine how many numbers in the vector are >= 139
#Divide this by the total length of the vector 

#8c
x<-rbinom(5000, size=200, prob=0.5);
x;
hist(x);

which(x>=139);
which(x[]>139); #What is the difference between this and the previous line?
y<-length(which(x>=139));
y;

z<-y/length(x)
z;

cat("Probability of the data under the null hypothesis: ", z, '\n')
